import sys
import os
import numpy as np


def detect_yolo(net, meta, inpt, version="alexeyab", score_min=0.45, 
                score_min_class_specific=None, classes_filter=None, verbose=True, **kwargs):
    """ Detect objects based on YOLO model

    :param inpt: ndarray
        The array of image for detecting objects.
    :param inpt_obj: InputObject
        The InputObject generated by the generator.
    :param stored_obj: StoredObject
        The list of StoredObject generated by the storer.
    :param kwargs: dict
        The dict of arguments passed
        model_name: string
            Name of the model name to be loaded from the storer.
        score_min: float, optional, default to 0.45
            Minimum score threshold of YOLO detection

    :return: pd.DataFrame
        Bounding boxes of detected objects
    """
    try:
        boxes = yolo(net, meta, inpt, score_min=score_min, version=version)
        if verbose:
            print("boxes={}".format(boxes))
        boxes_final = []
        for box in boxes:
            obj_class = box[0]
            obj_score = float(box[1])
            obj_coords = list(box[2])
            if isinstance(obj_class, bytes or unicode):
                obj_class = obj_class.decode()
            box = (obj_class, obj_score, obj_coords)
            if (not classes_filter or (classes_filter and (obj_class in classes_filter))) and \
                    (score_min_class_specific is None or score_min_class_specific.get(obj_class) is None or
                             obj_score >= score_min_class_specific[obj_class]):
                boxes_final.append(box)
        if verbose:
            print("boxes_final={}".format(boxes_final))
        return boxes_final
    except:
        print("Failed to apply YOLO detection")
        raise

def import_darknet(version="alexeyab"):
    try:
        if version in ["3", 3, "v3"]:
            print("Importing library darknet for YOLO v3")
            #sys.path.insert(0, "/cyclope/cyclope-eye/deps/darknet3/python/")
            global dn3
            #import darknet3 as dn3
            import utils.darknet3 as dn3
        elif version in ["2", 2, "v2"]:
            print("Importing library darknet for YOLO v2")
            #sys.path.insert(0, "/cyclope/cyclope-eye/deps/darknet/python/")
            global dn2
            import utils.darknet2 as dn2
        elif version == "alexeyab":
            print("Importing library darknet for YOLO AlexeyAB")
            sys.path.insert(0, "/cyclope/share/deps/darknet-alexeyab/")
            global dnab
            #import utils.darknet as dnab
            import darknet as dnab
    except:
        raise
    return


def load_yolo(dict_path, version="alexeyab"):
    try:
        import_darknet(version=version)
        print("Loading YOLO model")
        if version in ["3", 3, "v3"]:
            from utils.darknet3 import load_net, load_meta
        elif version in ["2", 2, "v2"]:
            from utils.darknet2 import load_net, load_meta
        elif version == "alexeyab":
            #from utils.darknet import load_net_custom as load_net, load_meta
            from darknet import load_net_custom as load_net, load_meta

        if dict_path.get("cfg") and dict_path.get("weights"):
            cfg = dict_path.get("cfg").encode('utf-8')
            weights = dict_path.get("weights").encode('utf-8')
            if version == "alexeyab":
                net = load_net(cfg, weights, 0, 1)
            else:
                net = load_net(cfg, weights, 0)
        else:
            net = None

        print("Loading YOLO metadata")
        if dict_path.get("meta"):
            print("meta path={}".format(dict_path.get("meta")))
            meta = load_meta(dict_path.get("meta").encode('utf-8'))
        else:
            print("No YOLO meta path")
            meta = None

        res_dict = {"net": net,
                    "meta": meta}
        print("YOLO Model loaded - {}".format(res_dict))

        return res_dict
    except:
        print("Failed to load YOLO model")
        raise


def yolo(net, meta, frame, score_min=0.45, version="alexeyab"):
    try:
        #print("Detecting objects with YOLO and reformatting coordinates")
        boxes, probs = detect_objects(net, meta, frame, score_min=score_min, version=version)

        if version in ["2", 2, "v2"]:
            boxes = reformat_boxes(net, meta, boxes, probs)
        else:
            boxes = probs
        return boxes
    except:
        print("Failed to apply YOLO detection")
        raise


def nparray_to_image(img):
    data = img.ctypes.data_as(dn3.POINTER(dn3.c_ubyte))
    image = dn3.ndarray_image(data, img.ctypes.shape, img.ctypes.strides)
    return image


def detect_objects(net, meta, image, score_min=.45, hier_thresh=.5, nms=.45, version="alexeyab", verbose=False):
    if verbose:
        print("Detecting objects based on model {}".format(net))

    if version in ["2", 2, "v2"]:
        im = dn2.array_to_image(image)
        boxes = dn2.make_boxes(net)
        probs = dn2.make_probs(net)
        num = dn2.num_boxes(net)
        dn2.network_detect(net, im, score_min, hier_thresh, nms, boxes, probs)
        count = 0
        for j in range(num):
            for i in range(meta.classes):
                if probs[j][i] > 0:
                    count += 1
                    # dn2.free_image(im)
                    # dn2.free_ptrs(dn2.cast(probs, dn2.POINTER(dn2.c_void_p)), num)
    elif version in ["3", 3, "v3"]:
        im = nparray_to_image(image)
        num = dn3.c_int(0)
        pnum = dn3.pointer(num)
        dn3.predict_image(net, im)
        boxes = dn3.get_network_boxes(net, im.w, im.h, score_min, hier_thresh, None, 0, pnum)
        num = pnum[0]
        if (nms): dn3.do_nms_obj(boxes, num, meta.classes, nms);
        probs = []
        count = 0
        for j in range(num):
            for i in range(meta.classes):
                if boxes[j].prob[i] > 0:
                    b = boxes[j].bbox
                    xmax = 0.5 * (2 * b.x + b.w)
                    xmin = 0.5 * (2 * b.x - b.w)
                    ymax = 0.5 * (2 * b.y + b.h)
                    ymin = 0.5 * (2 * b.y - b.h)
                    obj_class = meta.names[i]
                    if isinstance(obj_class, bytes):
                        obj_class = obj_class.decode("utf-8")
                    probs.append((obj_class, boxes[j].prob[i], (xmin, ymin, xmax, ymax)))
                    count += 1
        probs = sorted(probs, key=lambda x: -x[1])
        dn3.free_image(im)
        dn3.free_detections(boxes, num)
    elif version == "alexeyab":
        # im = nparray_to_image(image)
        # custom_image = cv2.resize(custom_image_rgb,(dn3.lib.network_width(net), dn3.lib.network_height(net)), interpolation = cv2.INTER_LINEAR)
        im, _ = dnab.array_to_image(image)
        num = dnab.c_int(0)
        pnum = dnab.pointer(num)
        dnab.predict_image(net, im)
        boxes = dnab.get_network_boxes(net, im.w, im.h, score_min, hier_thresh, None, 0, pnum, 0)
        num = pnum[0]
        if nms:
            dnab.do_nms_sort(boxes, num, meta.classes, nms)
        probs = []
        count = 0
        for j in range(num):
            for i in range(meta.classes):
                if boxes[j].prob[i] > 0:
                    b = boxes[j].bbox
                    xmax = 0.5 * (2 * b.x + b.w)
                    xmin = 0.5 * (2 * b.x - b.w)
                    ymax = 0.5 * (2 * b.y + b.h)
                    ymin = 0.5 * (2 * b.y - b.h)
                    obj_class = meta.names[i]
                    if isinstance(obj_class, bytes):
                        obj_class = obj_class.decode("utf-8")
                    probs.append((obj_class, boxes[j].prob[i], (xmin, ymin, xmax, ymax)))
                    count += 1
        probs = sorted(probs, key=lambda x: -x[1])
        # dnab.free_image(im)
        dnab.free_detections(boxes, num)
        
    if verbose:
        print("Detected {} objects".format(str(count)))
    return boxes, probs


def reformat_boxes(net, meta, boxes, probs):
    print("Reformatting boxes coordinates")
    boxes_reformatted = []
    num = dn2.num_boxes(net)
    for j in range(num):
        for i in range(meta.classes):
            if probs[j][i] > 0:
                xmax = 0.5 * (2 * boxes[j].x + boxes[j].w)
                xmin = 0.5 * (2 * boxes[j].x - boxes[j].w)
                ymax = 0.5 * (2 * boxes[j].y + boxes[j].h)
                ymin = 0.5 * (2 * boxes[j].y - boxes[j].h)
                obj_class = meta.names[i]
                if isinstance(obj_class, bytes):
                    obj_class = obj_class.decode("utf-8")
                boxes_reformatted.append((obj_class, probs[j][i], (xmin, ymin, xmax, ymax)))
    boxes_reformatted = sorted(boxes_reformatted, key=lambda x: -x[1])
    # dn2.free_ptrs(dn2.cast(probs, dn2.POINTER(dn2.c_void_p)), num)
    return boxes_reformatted
